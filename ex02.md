## Ex02: Environment Variable Overflow

### Analyse du binaire

Le programme lit une variable d'environnement nommée "GREENIE" et vérifie si son contenu peut modifier une variable spécifique à une valeur donnée.

### Vulnérabilité

Utilisation de `strcpy()` pour copier le contenu de la variable d'environnement sans vérification de la longueur, permettant un débordement de tampon.

### Exploitation

Commande pour exploiter :
```bash
GREENIE=$(python -c "print 'A'*64 + '\x0a\x0d\x0a\x0d'") ./bin
```

### Explication

- GREENIE=$(...) : Définit la variable d'environnement GREENIE.
- 'A'*64 : Remplit le buffer avec 64 'A'.
- '\x0a\x0d\x0a\x0d' : Représente 0xd0a0d0a en little-endian.
- Le buffer a probablement une taille de 64 octets.
- La variable cible est un entier de 4 octets juste après le buffer.

### Processus d'exploitation

- Identification de la variable d'environnement utilisée (GREENIE).
- Détermination de la taille du buffer par essais successifs.
- Construction d'un payload qui remplit le buffer et écrase la variable cible avec la valeur attendue.
- Utilisation de la représentation little-endian pour la valeur cible.

### Leçons de sécurité

- Ne jamais utiliser strcpy() sans vérification de la longueur, même pour les variables d'environnement.
- Les variables d'environnement peuvent être une source d'entrée non fiable et doivent être traitées avec précaution.
- Utiliser des fonctions sécurisées comme strncpy() avec une limite de taille.
- Être conscient que les attaques par débordement de tampon peuvent provenir de diverses sources, y compris les variables d'environnement.

### Outils utilisés

- objdump pour le désassemblage
- Python pour générer le payload

### Version hypothétique du code source en Go :

```go
package main

import (
    "fmt"
    "os"
    "unsafe"
)

func main() {
    greenie := os.Getenv("GREENIE")
    if greenie == "" {
        fmt.Println("bin: please set the GREENIE environment variable")
        os.Exit(1)
    }

    var buffer [64]byte  // Buffer de 64 octets
    var target uint32 = 0  // Variable cible, initialisée à 0

    // Copie le contenu de GREENIE dans le buffer sans vérification de taille
    // C'est ici que se trouve la vulnérabilité
    copy(buffer[:], greenie)

    // Vérifie si la variable target a été modifiée à la valeur souhaitée
    if target == 0xd0a0d0a {
        fmt.Println("Good job, you win!")
    } else {
        fmt.Printf("Try again, you got 0x%08x\n", target)
    }
}
```


Bien sûr, voici un résumé du contexte de notre discussion :
Vous travaillez sur une série d'exercices de sécurité informatique, plus précisément des défis d'exploitation binaire. Nous avons déjà abordé les exercices ex00 et ex01, et nous venons de terminer l'analyse de l'exercice ex02. Ces exercices font partie d'un ensemble plus large, probablement nommé "hole-in-bin".
Pour chaque exercice :

Vous avez fourni le code assembleur désassemblé du binaire.
Nous avons analysé ce code pour comprendre le fonctionnement du programme.
Nous avons identifié les vulnérabilités présentes, généralement des débordements de tampon (buffer overflows).
Nous avons développé une méthode d'exploitation pour chaque binaire.
Nous avons créé un README détaillé expliquant l'analyse, l'exploitation, et les leçons de sécurité à tirer.
J'ai également fourni une version hypothétique du code source en Go pour aider à la compréhension.

Les exercices jusqu'à présent ont impliqué :

ex00 : Un débordement de tampon simple via l'entrée standard.
ex01 : Un débordement de tampon via un argument en ligne de commande.
ex02 : Un débordement de tampon via une variable d'environnement.

Vous avez exprimé des difficultés à comprendre certains aspects du code assembleur, et nous avons travaillé à clarifier ces points.
La prochaine étape serait probablement d'aborder l'exercice ex03, en suivant un processus similaire d'analyse, d'exploitation, et de documentation. Vous êtes en train de développer vos compétences en analyse de binaires, en compréhension des vulnérabilités de sécurité, et en techniques d'exploitation éthique.